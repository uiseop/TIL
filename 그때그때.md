# ✅ HTTP vs HTTPS 
<p align="center">
  <img src="http://blog.wishket.com/wp-content/uploads/2020/02/03-3.png" alt="text" style="width:550px;"/>
</p>

<code>http</code> : 하이퍼 텍스트 전송 프로토콜의 약자로 **서로 다른 시스템들 사이에서 통신을 주고받게 해주는 가장 기초적인 프로토콜**이다. 웹 서핑을 할 때 서버에서 브라우저로 데이터를 전송해주는 용도로 가장 많이 사용

<code>https</code> : http + 보안(Secure)의 약자로 일반 HTTP의 문제인 서버에서부터 브라우저로 전송되는 **정보가 암호화되지 않는것(도난/하이제킹의 위험)** 을  **SSL(보안소켓계층)** 을 사용함으로써 해결하쥐. SSL은 서버와 브라우저 사이에 안전하게 암호화된 연결을 만들 수 있게 도와주고, 서버-브라우저가 민감한 정보를 주고받을 때 이것이 도난당한 것을 막아준다. 그 외에도 <code>TLS(전송계층보안)</code> 프로토콜을 통해서도 보안을 유지하는데, 이 계층에서 데이터 무결성을 제공하기 때문에 데이터가 전송 중에 손상되거나 수정되는것을 방지하고, 사용자가 자신이 의도하는 웹사이트와 통신하고 있음을 입증하는 인증 기능도 제공하고 있다

또한 <code>SEO품질</code>의 차이도 있는데, 이는 검색엔진최적화(더 잘 검색됨)를 뜻하며, 구글에서 HTTPS 웹사이트에 가산점을 주기도 하고, 사용자들이 결국에는 가장 안전하다고 생각하는 웹사이트를 더 많이 사용하니까 그렇겠지??

**가속화된 모바일 페이지(AMP,Accelerated Mobile Pages)** 를 만들때에도 HTTPS를 반드시 사용해야만 한데, 이건 구글에서 만든건데(역시 구글..👍), 모바일 기기에서 빠르게 콘텐츠를 로딩할 수 있도록 html에서 불필요한 부분을 없앤 것이래.

스마트폰 유저가 많아진 지금, 무엇보다도 모바일 친화적인 웹사이트를 만들고, 검색엔진의 추천을 받으려면 아무래도 HTTP'S'를 사용하는게 좋겠지???

# 🎁 정리 : 1. 보안, 2. SEO품질 3. 모바일페이지

<hr/>

# ✅ URL vs URI
<p align="center">
  <img src="https://media.vlpt.us/images/jch9537/post/88b0c8ac-5870-4cbc-b613-7dd39f510f31/image.png" alt="text" style="width:550px"/>
</p>

<code>URL</code> : Uniform Resource Locater(통합 자원 탐지기?)의 약자로 자원에 대한 참조이자 **해당 자원에 접근하는 방법** 이라고 해. 인터넷에 있는 자원의 위치를 알려주는 애지. 흔히 웹사이트 주소라고도 부르며 브라우저 주소창에서 쉽게 확인할 수 있지. 절대 주소상 인터넷의 어디 디렉터리의 어떤 파일을 읽어와달라! 주소를 입력해서 꺼내는거야. **protocol ~ path** 까지가 URL이라 보면 돼!

<code>URI</code> : Uniform Resource Identifier(통합 자원 식별자)의 약자로 인터넷에 있는 자원을 나타내는 **유일한** 주소야. **protocol ~ query string**까지 포함하는것이 URI라고 해! 🤔 query string에서 <code>?id=HTMML&page=12</code> 이 부분은 위치를 알려주는 것이 아니라 id값이 HTML이고, page가 12인것을 나타내주는 식별하는 부분(filter라고 생각하면 되겠네!)

# 🎁 정리 : URL은 책 이름, URI는 책 상세정보

<hr/>

# ✅ 절차지향 vs 객체지향 vs 함수형
<p align="center">
  <img src="https://t1.daumcdn.net/cfile/tistory/999846405C6C2E061F" width="550px">
</p>

<code>절차지향</code> : 물이 위에서 아래로 흐르는 것처럼 <b>순차적인 처리</b>가 중요시 되며 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법이야. 절차적으로만 만들어야 하기때문에, 중간에 고장이나면 전체 기능이 마비되는것과 같은 문제점이있어. 대표적인 절챠지향 언어에는 C언어가 있지. 얘는 컴퓨터의 작업처리와 유사하기 때문에 객체지향 언어를 사용하는 것에 비해 더 빨리 처리되어 시간적으로 유리해. 그런데 기술이 발전하면서 소프트웨어✈와 하드웨어🐢의 발달에 차이가 나면서 객체지향프로그래밍이 등장했어.

<code>객체지향</code> : 객체지향은 개발하려는 것을 기능별로 묶어 모듈화를 함으로써 하드웨어가 같은 기능을 중복으로 연산하지 않도록 하고, 모듈을 재사용하기 때문에 하드웨어의 처리량을 획기절으로 줄여주었지!
객체지향의 정의는 <b>실제 세계를 모델링</b>하여 소프트웨어를 개발하는 방법으로, 데이터와 절차를 하나의 덩어리로 묶어서 생각하게 돼. 이는 마치 자동차 부품을 하나씩 만들어 조립하는 것과 같은 방법이야! 

객체지향의 대표적인 특성으로는 <code>캡.상.추.다</code>가 있는데, 캡슐화(정보의 은닉), 상속(재사용), 추상화(모델링), 다형성(사용편의)으로 각각 설명해보자
- 캡슐화 : 관련된 데이터와 코드들이 하나의 묶음으로 정리된 것. 데이터를 감추고 외부 세계와의 상호작용은 메소드를 통하는 방법인데, 라이브러리를 사용하는것이 그 예다! 변수와 함수를 묶는것을 말하지.
- 상속 : 이미 작성된 클래스를 이어 받아서 새로운 클래스를 생성하는 기법으로, 코드를 재사용하는 부분!
- 추상화 : 구체적인 것을 분해해서 관심 영역에 있는 특성만 가지고 재조합 하는것. 가령 클래스를 정의하는것을 바로 추상화라고 할 수 있는데, 물고기,사자,토끼,뱀을 우리는 각각을 객체라고 부르고 동물이라는 추상적인 객체로 동물을 다시 생물이라는 추상적인 객체로 묶을 수 있다.
- 다형형 : 하나의 이름으로 많은 상황에 대처하는 기법(오버로딩👨‍👨‍👧‍👧/라이딩🧙‍♂️). 개념적으로 동일한 작업을 하는 함수들에 똑같은 이름을 부여할 수 있으므로 코드가 더 간단해지는 효과가 있지!

<code>함수형</code> : 순수함수를 조합하고 공유상태, 변경가능한 데이터 및 부작용을 피하여 프로그래밍하는 패러다임이다. 다시말해 연계성을 생각하기보다는 함수를 이용해서 사이드 이펙트가 없도록 선언형 프로그래밍을 하는 것이 함수형 프로그래밍인 것이다. 

# 🎁 정리 : 
# - 절차지향 : 가독성/개발속도/실행속도 빠름 but 유지보수 어려움/길면 분석하기 힘들어
# - 객체지향 : 재사용성/유지보수/확장성 but 개발속도/실행속도 느림
# - 함수형 : 사이드이펙트가 없다/간결하다 but 상태(State)가 없다(react는 가능)

<hr/>

# ✅ REST API란?
<p align="center">
  <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbRWN9I%2FbtqHlWwL8nE%2F5QITw2lZkBu4gpOadhyWwK%2Fimg.png" width="550px">
</p>

<code>REST란?</code> Representational State Transfer의 약자이며, 자원(URI), 행위(HTTP), 표현(Representation)으로 URI를 통해 자원을 표시하고, HTTP Method를 이용하여 해당 자원의 행위를 규정하여 결과를 받는것을 말한다.

HTTP Method는 <code>GET,POST,PUT,DELETE</code> 가 대표적이며 보통 CRUD에서 조회는 GET, 등록은 POST, 수정은 PUT👉변경사항 포함 모두 보내야함. 변경사항만 보내면 기존데이터는 null(PATCH👉변경사항만 보내도 돼), 삭제는 DELETE를 사용한다. <br>

<code>HEAD</code> : 클라이언트가 자원에 대한 정보를 요청하고 자원 자체를 요청하지 않을 때 사용된다<br>
<code>OPTION</code> : 클라이언트가 웹 서버에서 문서를 검색하거나 처리할 수 있는 다른 방법을 결정하려고 할 때 사용된다<br>
<code>CONNECT</code> : 클라이언트가 원격 호스트에 투명한 연결을 설정하려고 할 때 사용되면 HTTP프록시를 통해 HTTPS를 용이하게 한다

<hr/>

# ✅ 프록시란?
<p align="center">
  <img src="https://t1.daumcdn.net/cfile/tistory/996F8D455A5049630B" width="550px">
</p>

<code>프록시란?</code> : <code>대신</code> 이라는 의미를 가지고 있댜. 프로토콜에 있어 대리 응답 등에서 사용하는 개념이라고 할 수 있겠다. 보안상의 문제로 직접 통신을 주고 받을 수 없는 사이에서 프록시를 이용해서 중계를 하는 개념이라고 볼 수 있겠다. <b>중계 기능을 하는 것</b>을 우리는 <code>프록시 서버</code>라고 부른다.

프록시를 사용하는 이유는 단순히 보안 떄문은 아니다. 프록시 서버에 요청된 내용들은 <code>캐시</code>를 이용해 저장해 두다가 다시 같은 내용을 요청하면 전송시간을 절약할 수 있는 이점도 생기지.

프록시서버는 서버의 위치에 따라 크게 두가지로 나뉘게 되는데 

 <p align="center">
 <img src="https://t1.daumcdn.net/cfile/tistory/998E0D4C5A5049790D" width="400px">
 </p>
 
- Foward Proxy
  - 내부망👉외부망으로 데이터가 전달될때, 가고싶은 목적지를 프록시로 보내면 프록시가 목적지 사이트의 내용을 받아와서 전달해주는 개념으로 ☝처음 말한 <code>대신</code> 처리해주는 역할. 캐싱기능과 특정사이트는 접근이 불가능 하도록 <code>제한</code>을 걸수 있는 기능도 있어 기업환경에서 많이 사용된대
 

 <p align="center">
 <img src="https://t1.daumcdn.net/cfile/tistory/99996E435A5049860C" width="400px">
 </p>
 
- Reverse Proxy 
  - 사용자가 Reverse Proxy로 설정된 서버의 주소로 데이터를 요청하면 프록시 서바가 요청을 받아서 실제 내부 서버에서 데이터를 받아와 클라이언트에게 전달을 해 주는 개념. 다이렉트로 하지 않고, 프록시를 경유 해 가는 이유는 바로 <code>보안</code>때문이다.
  - 중간에 Proxy를 거치지 않고 다이렉트로 하게 될 경우 하나만 해킹하면 모두 해킹할 수 있기때문에 보안상의 이유로 이렇게 둔다고 한다.

# 🎁 정리 : 프록시는 1. 우체국(캐시+대신) 2. 보안업체같은 곳

<hr/>

# ✅ 토큰 기반 인증 

과거에는 서버의 세션 안에 사용자의 로그인 상태를 갖고있었음. 👉 세션 기반 인증 방식<br/>
로그인 정보가 많으면?? 👉 서버의 부하가 걸려 👉 서버를 여러대 놨었었음. 때문에 어디 서버에 누구의 정보가 들어가있는지 고민을 했었음 등의 문제가 많았댜

최근에는 세션 기반 인증 방식 대신에 ```토큰 기반 인증방식```을 사용하게 되었음. 이는 유저의 로그인정보(인증정보)를 세션에 담지않는 인증 방식. ```사용자정보```를 나만쓰는 합격목걸이같은 ```토큰```을 제공해줘. 이 토큰을 갖고 서버에서 이에 맞는 권한을 주게 됐어

- ```OAuth``` : 외부서비스의 인증 및 ```권한```부여를 관리하는 프레임워크
  1. ```클라이언트```와 ```서버``` 사이에 인증을 하면 서버가 기간이 정해진 ```access_token```을 줌
  2. 클라이언트는 ```access_token```을 이용해서 API를 이용할 수 있어
  3. 클라이언트는 이 권한을 가지고 권한서버에 ```access_token```을 요청함
  4. 클라이언트는 이 ```access_token```을 가지고 구글에서 ```유저정보```를 가져올 수 있지
  5. 구글은 클라이언트가 보낸 ```access_token```을 가지고 권한의 유무를 확인해서 결과를 보내줘
- ```JWT(Json Web Token)``` : 토큰의 한 형식! 데이터가 JSON형태로 이뤄져있는 토큰 - 전자서명이 포함된 토큰으로 조금더 발전된 토큰
  1. header, payload(내용), signature 형태로 구성되어있어
  2. 동작방식은 OAuth와 동일해. 로그인 시도를 하면 JWT를 전달하고 이 JWT를 수정해서 다시 반납하는 방식

- ```쿠키``` : 클라이언트  로컬에 저장되는 키-밸류 형태의 저장소다! 약 4KB정도 저장할 수 있쥐 ```document.cookie = "MY_COOKIE=cookie;";``` 로 만들 수 있어. 만료일도 정할 수있지
- ```세션스토리지``` : 키랑 비슷하게 키-밸류 저장소야! 그렇지만 브라우저를 끄면 다 날아가! ```sessionStorage.setItem('my_session','here') getItem('mysession')``` 해서 저장, 검색이 가능해
- ```로컬스토리지``` : 브라우저를 꺼도 사라지지 않음. 따로 삭제해주지 않는이상 사라지지 않아!. 사용법은 localStorage.하고 세션의 명령어랑 같다!

그렇다면 ```토큰```은 어디에다가 저장할까? 각각 장단점이 달라. 
  - 쿠키 : HTTP통신을 할때 같이 넘어가! but, 사용감이 조금 불편..만료일이나 데이터가 너무 많아서! 또, 저장소가 4kb뿐이라 용량이 부족할수도..?
  - 로컬 : 저장소가 5MB라 쿠키보다 많이 저장할 수 있어. HTTP통신에 모두 딸려가지 않아. 
 