# ✅ HTTP vs HTTPS 
<p align="center">
  <img src="http://blog.wishket.com/wp-content/uploads/2020/02/03-3.png" alt="text" style="width:550px;"/>
</p>

<code>http</code> : 하이퍼 텍스트 전송 프로토콜의 약자로 **서로 다른 시스템들 사이에서 통신을 주고받게 해주는 가장 기초적인 프로토콜**이다. 웹 서핑을 할 때 서버에서 브라우저로 데이터를 전송해주는 용도로 가장 많이 사용

<code>https</code> : http + 보안(Secure)의 약자로 일반 HTTP의 문제인 서버에서부터 브라우저로 전송되는 **정보가 암호화되지 않는것(도난/하이제킹의 위험)** 을  **SSL(보안소켓계층)** 을 사용함으로써 해결하쥐. SSL은 서버와 브라우저 사이에 안전하게 암호화된 연결을 만들 수 있게 도와주고, 서버-브라우저가 민감한 정보를 주고받을 때 이것이 도난당한 것을 막아준다. 그 외에도 <code>TLS(전송계층보안)</code> 프로토콜을 통해서도 보안을 유지하는데, 이 계층에서 데이터 무결성을 제공하기 때문에 데이터가 전송 중에 손상되거나 수정되는것을 방지하고, 사용자가 자신이 의도하는 웹사이트와 통신하고 있음을 입증하는 인증 기능도 제공하고 있다

또한 <code>SEO품질</code>의 차이도 있는데, 이는 검색엔진최적화(더 잘 검색됨)를 뜻하며, 구글에서 HTTPS 웹사이트에 가산점을 주기도 하고, 사용자들이 결국에는 가장 안전하다고 생각하는 웹사이트를 더 많이 사용하니까 그렇겠지??

**가속화된 모바일 페이지(AMP,Accelerated Mobile Pages)** 를 만들때에도 HTTPS를 반드시 사용해야만 한데, 이건 구글에서 만든건데(역시 구글..👍), 모바일 기기에서 빠르게 콘텐츠를 로딩할 수 있도록 html에서 불필요한 부분을 없앤 것이래.

스마트폰 유저가 많아진 지금, 무엇보다도 모바일 친화적인 웹사이트를 만들고, 검색엔진의 추천을 받으려면 아무래도 HTTP'S'를 사용하는게 좋겠지???

# 🎁 정리 : 1. 보안, 2. SEO품질 3. 모바일페이지

<hr/>

# ✅ URL vs URI
<p align="center">
  <img src="https://media.vlpt.us/images/jch9537/post/88b0c8ac-5870-4cbc-b613-7dd39f510f31/image.png" alt="text" style="width:550px"/>
</p>

<code>URL</code> : Uniform Resource Locater(통합 자원 탐지기?)의 약자로 자원에 대한 참조이자 **해당 자원에 접근하는 방법** 이라고 해. 인터넷에 있는 자원의 위치를 알려주는 애지. 흔히 웹사이트 주소라고도 부르며 브라우저 주소창에서 쉽게 확인할 수 있지. 절대 주소상 인터넷의 어디 디렉터리의 어떤 파일을 읽어와달라! 주소를 입력해서 꺼내는거야. **protocol ~ path** 까지가 URL이라 보면 돼!

<code>URI</code> : Uniform Resource Identifier(통합 자원 식별자)의 약자로 인터넷에 있는 자원을 나타내는 **유일한** 주소야. **protocol ~ query string**까지 포함하는것이 URI라고 해! 🤔 query string에서 <code>?id=HTMML&page=12</code> 이 부분은 위치를 알려주는 것이 아니라 id값이 HTML이고, page가 12인것을 나타내주는 식별하는 부분(filter라고 생각하면 되겠네!)

# 🎁 정리 : URL은 책 이름, URI는 책 상세정보

<hr/>

# ✅ 절차지향 vs 객체지향 vs 함수형
<p align="center">
  <img src="https://t1.daumcdn.net/cfile/tistory/999846405C6C2E061F" width="550px">
</p>

<code>절차지향</code> : 물이 위에서 아래로 흐르는 것처럼 <b>순차적인 처리</b>가 중요시 되며 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법이야. 절차적으로만 만들어야 하기때문에, 중간에 고장이나면 전체 기능이 마비되는것과 같은 문제점이있어. 대표적인 절챠지향 언어에는 C언어가 있지. 얘는 컴퓨터의 작업처리와 유사하기 때문에 객체지향 언어를 사용하는 것에 비해 더 빨리 처리되어 시간적으로 유리해. 그런데 기술이 발전하면서 소프트웨어✈와 하드웨어🐢의 발달에 차이가 나면서 객체지향프로그래밍이 등장했어.

<code>객체지향</code> : 객체지향은 개발하려는 것을 기능별로 묶어 모듈화를 함으로써 하드웨어가 같은 기능을 중복으로 연산하지 않도록 하고, 모듈을 재사용하기 때문에 하드웨어의 처리량을 획기절으로 줄여주었지!
객체지향의 정의는 <b>실제 세계를 모델링</b>하여 소프트웨어를 개발하는 방법으로, 데이터와 절차를 하나의 덩어리로 묶어서 생각하게 돼. 이는 마치 자동차 부품을 하나씩 만들어 조립하는 것과 같은 방법이야! 

객체지향의 대표적인 특성으로는 <code>캡.상.추.다</code>가 있는데, 캡슐화(정보의 은닉), 상속(재사용), 추상화(모델링), 다형성(사용편의)으로 각각 설명해보자
- 캡슐화 : 관련된 데이터와 코드들이 하나의 묶음으로 정리된 것. 데이터를 감추고 외부 세계와의 상호작용은 메소드를 통하는 방법인데, 라이브러리를 사용하는것이 그 예다! 변수와 함수를 묶는것을 말하지.
- 상속 : 이미 작성된 클래스를 이어 받아서 새로운 클래스를 생성하는 기법으로, 코드를 재사용하는 부분!
- 추상화 : 구체적인 것을 분해해서 관심 영역에 있는 특성만 가지고 재조합 하는것. 가령 클래스를 정의하는것을 바로 추상화라고 할 수 있는데, 물고기,사자,토끼,뱀을 우리는 각각을 객체라고 부르고 동물이라는 추상적인 객체로 동물을 다시 생물이라는 추상적인 객체로 묶을 수 있다.
- 다형형 : 하나의 이름으로 많은 상황에 대처하는 기법(오버로딩👨‍👨‍👧‍👧/라이딩🧙‍♂️). 개념적으로 동일한 작업을 하는 함수들에 똑같은 이름을 부여할 수 있으므로 코드가 더 간단해지는 효과가 있지!

<code>함수형</code> : 순수함수를 조합하고 공유상태, 변경가능한 데이터 및 부작용을 피하여 프로그래밍하는 패러다임이다. 다시말해 연계성을 생각하기보다는 함수를 이용해서 사이드 이펙트가 없도록 선언형 프로그래밍을 하는 것이 함수형 프로그래밍인 것이다. 

# 🎁 정리 : 
# - 절차지향 : 가독성/개발속도/실행속도 빠름 but 유지보수 어려움/길면 분석하기 힘들어
# - 객체지향 : 재사용성/유지보수/확장성 but 개발속도/실행속도 느림
# - 함수형 : 사이드이펙트가 없다/간결하다 but 상태(State)가 없다(react는 가능)

<hr/>

# ✅ REST API란?
<p align="center">
  <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbRWN9I%2FbtqHlWwL8nE%2F5QITw2lZkBu4gpOadhyWwK%2Fimg.png" width="550px">
</p>

<code>REST란?</code> Representational State Transfer의 약자이며, 자원(URI), 행위(HTTP), 표현(Representation)으로 URI를 통해 자원을 표시하고, HTTP Method를 이용하여 해당 자원의 행위를 규정하여 결과를 받는것을 말한다.

HTTP Method는 <code>GET,POST,PUT,DELETE</code> 가 대표적이며 보통 CRUD에서 조회는 GET, 등록은 POST, 수정은 PUT👉변경사항 포함 모두 보내야함. 변경사항만 보내면 기존데이터는 null(PATCH👉변경사항만 보내도 돼), 삭제는 DELETE를 사용한다. <br>

<code>HEAD</code> : 클라이언트가 자원에 대한 정보를 요청하고 자원 자체를 요청하지 않을 때 사용된다<br>
<code>OPTION</code> : 클라이언트가 웹 서버에서 문서를 검색하거나 처리할 수 있는 다른 방법을 결정하려고 할 때 사용된다<br>
<code>CONNECT</code> : 클라이언트가 원격 호스트에 투명한 연결을 설정하려고 할 때 사용되면 HTTP프록시를 통해 HTTPS를 용이하게 한다

<hr/>

# ✅ 프록시란?
<p align="center">
  <img src="https://t1.daumcdn.net/cfile/tistory/996F8D455A5049630B" width="550px">
</p>

<code>프록시란?</code> : <code>대신</code> 이라는 의미를 가지고 있댜. 프로토콜에 있어 대리 응답 등에서 사용하는 개념이라고 할 수 있겠다. 보안상의 문제로 직접 통신을 주고 받을 수 없는 사이에서 프록시를 이용해서 중계를 하는 개념이라고 볼 수 있겠다. <b>중계 기능을 하는 것</b>을 우리는 <code>프록시 서버</code>라고 부른다.

프록시를 사용하는 이유는 단순히 보안 떄문은 아니다. 프록시 서버에 요청된 내용들은 <code>캐시</code>를 이용해 저장해 두다가 다시 같은 내용을 요청하면 전송시간을 절약할 수 있는 이점도 생기지.

프록시서버는 서버의 위치에 따라 크게 두가지로 나뉘게 되는데 

 <p align="center">
 <img src="https://t1.daumcdn.net/cfile/tistory/998E0D4C5A5049790D" width="400px">
 </p>
 
- Foward Proxy
  - 내부망👉외부망으로 데이터가 전달될때, 가고싶은 목적지를 프록시로 보내면 프록시가 목적지 사이트의 내용을 받아와서 전달해주는 개념으로 ☝처음 말한 <code>대신</code> 처리해주는 역할. 캐싱기능과 특정사이트는 접근이 불가능 하도록 <code>제한</code>을 걸수 있는 기능도 있어 기업환경에서 많이 사용된대
 

 <p align="center">
 <img src="https://t1.daumcdn.net/cfile/tistory/99996E435A5049860C" width="400px">
 </p>
 
- Reverse Proxy 
  - 사용자가 Reverse Proxy로 설정된 서버의 주소로 데이터를 요청하면 프록시 서바가 요청을 받아서 실제 내부 서버에서 데이터를 받아와 클라이언트에게 전달을 해 주는 개념. 다이렉트로 하지 않고, 프록시를 경유 해 가는 이유는 바로 <code>보안</code>때문이다.
  - 중간에 Proxy를 거치지 않고 다이렉트로 하게 될 경우 하나만 해킹하면 모두 해킹할 수 있기때문에 보안상의 이유로 이렇게 둔다고 한다.

# 🎁 정리 : 프록시는 1. 우체국(캐시+대신) 2. 보안업체같은 곳

<hr/>

# ✅ 토큰 기반 인증 

과거에는 서버의 세션 안에 사용자의 로그인 상태를 갖고있었음. 👉 세션 기반 인증 방식<br/>
로그인 정보가 많으면?? 👉 서버의 부하가 걸려 👉 서버를 여러대 놨었었음. 때문에 어디 서버에 누구의 정보가 들어가있는지 고민을 했었음 등의 문제가 많았댜

최근에는 세션 기반 인증 방식 대신에 ```토큰 기반 인증방식```을 사용하게 되었음. 이는 유저의 로그인정보(인증정보)를 세션에 담지않는 인증 방식. ```사용자정보```를 나만쓰는 합격목걸이같은 ```토큰```을 제공해줘. 이 토큰을 갖고 서버에서 이에 맞는 권한을 주게 됐어

- ```OAuth``` : 외부서비스의 인증 및 ```권한```부여를 관리하는 프레임워크
  1. ```클라이언트```와 ```서버``` 사이에 인증을 하면 서버가 기간이 정해진 ```access_token```을 줌
  2. 클라이언트는 ```access_token```을 이용해서 API를 이용할 수 있어
  3. 클라이언트는 이 권한을 가지고 권한서버에 ```access_token```을 요청함
  4. 클라이언트는 이 ```access_token```을 가지고 구글에서 ```유저정보```를 가져올 수 있지
  5. 구글은 클라이언트가 보낸 ```access_token```을 가지고 권한의 유무를 확인해서 결과를 보내줘
- ```JWT(Json Web Token)``` : 토큰의 한 형식! 데이터가 JSON형태로 이뤄져있는 토큰 - 전자서명이 포함된 토큰으로 조금더 발전된 토큰
  1. header, payload(내용), signature 형태로 구성되어있어
  2. 동작방식은 OAuth와 동일해. 로그인 시도를 하면 JWT를 전달하고 이 JWT를 수정해서 다시 반납하는 방식

- ```쿠키``` : 클라이언트  로컬에 저장되는 키-밸류 형태의 저장소다! 약 4KB정도 저장할 수 있쥐 ```document.cookie = "MY_COOKIE=cookie;";``` 로 만들 수 있어. 만료일도 정할 수있지
- ```세션스토리지``` : 키랑 비슷하게 키-밸류 저장소야! 그렇지만 브라우저를 끄면 다 날아가! ```sessionStorage.setItem('my_session','here') getItem('mysession')``` 해서 저장, 검색이 가능해
- ```로컬스토리지``` : 브라우저를 꺼도 사라지지 않음. 따로 삭제해주지 않는이상 사라지지 않아!. 사용법은 localStorage.하고 세션의 명령어랑 같다!

그렇다면 ```토큰```은 어디에다가 저장할까? 각각 장단점이 달라. 
  - 쿠키 : HTTP통신을 할때 같이 넘어가! but, 사용감이 조금 불편..만료일이나 데이터가 너무 많아서! 또, 저장소가 4kb뿐이라 용량이 부족할수도..?
  - 로컬 : 저장소가 5MB라 쿠키보다 많이 저장할 수 있어. HTTP통신에 모두 딸려가지 않아. 

# ✅ 깃(Git) 기본 개념 정리

1. 필수 개념
  - 작업공간 : 개인 컴퓨터 환경에서 소스코드를 편집하는 일반적인 프로젝트 폴더를 작업공간이라고 함.
  - 저장소(repository) : 작업공간을 Git이 제공하는 자료구조 안에 압축시켜 넣은 것. 일반적으로 저장소라고 하면 로컬 저장소를 가리키는데, `git init` 명령어로 해당 작업공간의 저장소를 생성하면 `.git`이라는 이름의 폴더가 생겨. 이 폴더가 바로 `Git 저장소`이고, 안에 모든 커밋들이 들어가있음
  - 커밋(변경사항/이력) : 버전 관리라고도 하지. 어떤 순간 작업공간의 상태를 저장한 것. 작업공간 안에 있는 모든 파일과 파일의 데이터를 사진 찍듯이 복사해서 저장소에 보존한다. `어떤 시점의 스냅샷`이라고 할 수 있다.
  - 원격 저장소 : 로컬에 있는것이 아니라, 다른 어딘가의 서버에 위치해 있으면 원격 저장소. 원격 저장소를 사용하면 여러 사람이 서버에 있는 `하나의 저장소를 공유해서 공동으로 작업할` 수 있기에 편리해

2. 배경지식
  - 깃 : 리눅스 커널을 개발자가 만든 `버전 관리 툴`. 리눅스 태생인 만큼 기본적으로 리눅스 기본 쉘(Bash)을 이용해서 깃 명령어를 하나씩 입력해 실행하는 방법으로 기능을 사용하지만, GUI 툴(버튼 클릭같은) 등도 존재해
  - 커밋의 대략적 구조 : `git commit -m` 명령어로 .git 저장소에 올리는 작업공간의 하나의 변경된 상태. 하나의 커밋이 더해질 때는 이전 커밋에서 변경된 사항만 추가하면 될 것이다. 이 때문에 서로 연결된 체인 구조를 형성하지. 👉 이전 커밋이 망가지면 그 이후 커밋도 망가져!

3. 용어1
  - 추적(stage) : 작업공간에서 `변경이 발생한 파일`을 `다음 커밋에 포함되도록` 예약하는 것을 추적이라고 해(옆에 초록색 하이라이트가 쳐져). 어떤 파일을 추적하면 그 파일을 `스테지이` 되었다고 한다. 추적되는 파일은 `스테이지 영역(stage area)`에 들어가 있게 돼
  - 추적해제(unstage) : 추적하고 있는 파일을 스테이지 영역에서 제외하는것. 👉 변경사항을 저장하지 않을것
  - 커밋해시(commit hash) : `git log` 명령어로 조회할 수 있는 `커밋 해시는`( 각 커밋을 구분하는 Extended SHA-1 형식의 )`식별자다`

4. 용어2
  - 브랜치(branch) : `커밋에서 분기하면` 브랜치가 된다. 말 그대로 한 갈래; 가지를 의미해. `지금껏 내가 사용한것이 브랜치였군..`
  - master : 기본 설정된(default) 브랜치에 붙는 이름
  - origin : 기본 설정된 원격 주소에 붙는 별명
  - 태그(tag) : 알아보기 쉽게 하기 위해서 커밋에 달아주는 별명 `-m 태그로 써서 하는건가??`
  - HEAD : 현 시점에서 작업중인 브랜치를 가리키는 포인터! 작업공간이 현재 위치해 있는 브랜치를 가리킵니다.

5. 파일
  - .git : 깃 저장소(repository) 폴더다
  - .gitignore : 작업공간 안에서 깃이 무시하게 하고 싶은 파일을 정의하는 파일. 이 때 `.gitignore` 파일 자신도 커밋되어 있어야 효력이 적용됨 👉 처음 만들때 같이 만드는게 좋다

6. 기본(로컬) 명령어
  - git status : 마지막 커밋 이후 작업공간에서 `변경이 일어난 모든 파일들을` 나열하는 명령어. 
  - git add : 해당 파일을 추적 시키는 명령어. 추적되고 있는 파일만(git add 한 파일만) 커밋에 포함된다.
  - git rm : 해당 파일을 추적해제(unstage) 시키는 명령어. `git add` 명령어의 반대다!
  - git commit : 추적시킨 파일들(변경된 파일들)을 .git에 추가하겠다는 명령어. 
  - git checkout : 커밋을 불러오는 명령어다. `git checkout(커밋 해시)` 형식으로 사용되지. 
  - git diff : 커밋과 커밋 사이의 변경사항을 확인할 수 있게 하는 명령어.

7. 원격 명령어
  - 