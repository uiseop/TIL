# 병합 정렬 (Merge Sort)
병합 정렬 혹은 합병 정렬이라고 불리는 Merge Sort는 데이터들을 잘게 쪼갠 다음에 하나로 합치는 과정에서 정렬하는 방법이다. 요즘은 데이터를 USB같은 장치로 저장하는 것이 일반적이었으나 아주 옛날에는 테이프를 이용해서 저장했다. 테이프 드라이브에 저장된 데이터를 정렬하는 일은 매우 어려운 일이었다. 왜냐면 테이프 드라이브는 항상 데이터를 처음부터 순차적으로 읽어야 한다는 특징이 있기 때문이다. 이러한 테이프 드라이브의 문제점 때문에 병합 정렬 알고리즘이 탄생하였다. 

## Divide and Conquer

즉 `분할하여 정복한다`는 이 기법은 알고리즘 문제를 해결하는 유명한 전략 중 하나이다.
1. 기본 문제를 해결한다. 이 부분은 가능한 하나의 간단한 문제여야 한다.
2. 문제가 기본 단계가 될 때까지 나누거나 작게 만든다.

`1 -> 2`의 과정을 통해서 일정한 규칙을 찾고, 재귀함수를 통해 큰 문제를 작게 만든다.
그런 후, 작게 푼 솔루션들을 다시 하나로 합침으로 문제를 해겷한다. 

## Big O
- Worst Case: O(nlogn)
- Best Case: O(nlogn)

병합 정렬은 데이터를 분할하는 단계와 다시 병합하는 단계로 나눌 수 있는데, 분할하는 단계는 시간복잡도에 포함되지 않는다.

데이터를 분할한 후 병합하는 단계에서 재귀 호출의 길이는 log₂n이다. 왜냐하면 1/2씩 쪼개진 배열을 합치기 때문이다. 그리고 그 각각의 단계에서 데이터의 개수만큼 크기를 비교하는 연산이 필요하기 때문에 최대 n번의 비교 연산을 하게 된다. 그러므로 병합 정렬의 시간 복잡도는 O(nlog₂n)이며 이는 최선의 경우이든 최악의 경우이든 동일하게 적용된다.

병합 정렬은 최선의 경우와 최악의 경우가 모두 O(nlog₂n)의 시간을 가지기 때문에 최악의 경우에 O(n^2)의 시간을 가지는 퀵 정렬보다 빠른 정렬이라고 생각하기 쉽다. 그러나 `항상 그런 것은 아니다.` 그 이유는 퀵 정렬이 병합 정렬보다 더 작은 상수 시간을 가지기 때문이다. 

예를 들어서 어떤 배열을 단순히 콘솔 창에 하나씩 출력하는 함수는 O(n)의 시간이 소요된다. 그런데 만약 setTimeout을 사용하여 콘솔 창에 출력하기 전 1초의 딜레이를 준다고 생각해보자. 이 경우 콘솔 창에 데이터를 출력할 때마다 1초를 더 기다려야하므로 실제 함수 실행 시간은 느려진다. 그러나 빅오 표기법에서는 이런 상수들을 보통 무시하기 때문에 두 함수 모두 O(n)이라고 표기한다.

퀵 정렬과 병합 정렬의 경우에도 두 정렬의 소요시간은 최선의 경우에 모두 O(nlog₂n)이라고 표현되지만 퀵 정렬이 병합 정렬보다 작은 상수값을 가지므로 최악의 경우가 아닌 경우엔 퀵 정렬이 병합 정렬보다 좀 더 빠르다.

![정렬시간복잡도](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdbiUou%2FbtqwWoI8MYK%2FB0oSILc2RJ4XAd0C0Swj30%2Fimg.png)

# 퀵 정렬 (Quick Sort)

## Basic Quick Sort - Not In Place

퀵 정렬은 병합 정렬에서 사용한 Divide and Conquer 전략을 사용한 알고리즘이다. 

즉, 정렬하는데 가장 간단한 배열은 바로 요소가 없거나 하나만 있는 배열이므로 모든 배열이 기본 배열이 될 때까지 큰 배열을 나눠야한다.

이 때 퀵 정렬에서는 요소 하나를 기준 원소인 pivot으로 설정한다. 그리고 기준 원소의 왼쪽에는 기준 원소보다 작은 값의 배열을 놓고 오른쪽에는 기준 원소보다 큰 값을 놓는다.

pivot 왼쪽에 놓여진 기준 원소보다 작은 배열에서 위와 같은 방법으로 다시 pivot을 설정하고 배열을 pivot을 기준으로 나눈다. 이 방법을 반복하면 결국 기본 단계인 원소가 하나만 있는 배열이 남는다.

위 방법의 퀵 정렬은 in place 방법이 아니기 때문에 `별도의 메모리 공간이 필요`하므로 데이터의 양이 많으면 공간적인 낭비가 심해져 실제로는 잘 쓰이지 않는 방법이다. 그러나 위의 방법으로 퀵 정렬을 할 경우에 중복되는 데이터는 순차적으로 pivot에 넣으면 되기 때문에 정렬 전 중복 데이터의 순서가 바뀌지 않는 `stable한 정렬`을 구현할 수 있다

## In place Quick Sort

위의 방법은 이해하기에 훨씬 쉽고 구현도 간단하지만 메모리 공간의 낭비가 심하기 때문에 위 방법보다는 in place 방법이 훨씬 더 많이 사용된다.

![Quick Sort](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbvk8dw%2FbtqwVhxq7vQ%2FF6wCsUPw77h1fGBej78S8k%2Fimg.png)

개념은 위의 그림과 같다.

정렬되지 않은 데이터에서 가운데 원소를 pivot으로 설정하고 가장 왼쪽 요소와 가장 오른쪽 요소가 시작점이다.

가장 왼쪽부터 값을 pivot값을 비교하여 pivot보다 큰 값이 나타날 때까지 칸을 오른쪽으로 이동한다.

가장 오른쪽부터 값을 pivot값을 비교하여 pivot보다 작은 값이 나타날 때까지 칸을 왼쪽으로 이동한다.

pivot보다 큰 왼쪽 값과 pivot보다 작은 오른쪽 값을 서로 교환한다.

왼쪽 인덱스가 오른쪽 인덱스보다 커지면 이동을 멈추고 그 자리에서 두 배열로 갈라서

각 배열에 위와 같은 방식으로 재귀 호출하여 정렬한다.

이 방법은 추가적인 공간을 필요로하지 않기 때문에 `메모리 공간이 절약`된다는 장점이 있으나, 왼쪽과 오른쪽 값을 교환하는 과정에서 중복값의 위치가 바뀔 수 있으므로 `unstable한 정렬` 방법이다.

## Big O
- Worst Case: O(n^2)
- Best Case: O(nlogn)

퀵 정렬은 대개의 경우 매우 좋은 성능을 보여준다. 최선의 경우에는 스택의 크기가 O(log₂n)이고 각 스택마다 요소의 개수만큼 검색하므로 총 O(n)을 순회하기 때문에 결과적으로 시간 복잡도는 O(nlog₂n)이다.

그러나 최악의 경우에는 스택의 크기가 O(n)이 되고 O(n)번 순회하므로 O(n^2)이란 시간이 소요된다.