# 왜 코딩 테스트를 보는가?

SW 기본 역량을 정량적으로 평가하는데 이 코딩테스트가 매우 유효하다고 생각한다. SW 기본 역량은 `문제해결 능력` + `구현 능력`이 갖춰져야 문제를 풀 수 있습니다. 이게 바로 SW 기본 역량이다. 따라서 이 역량을 평가하는데 제일 좋은 정량적 지표가 되기 때문에 코딩 테스트를 보는것이 아닐까 싶습니다. 
 - `문제 해결 능력` : 요구 사항이 들어왔을 때 이 요구 사항을 어떤 구현을 통해서 문제를 해결할 것인가? 아이디어
 - `구현 능력` : 언어에 맞춰 실제 이 요구 사항을 어떻게 Sw적으로 해결해 나갈것인가

# JS란??

- 객체 기반의 스크립트 프로그래밍 언어`(라인별로 실행되는)` 인터프리터 언어 (C,Java랑 달리 별도의 컴파일이 없어)
- ECMAScript 사양을 준수하는 범용 스크립팅 언어
- 자바와 연관은 없음. 웹의 동적 동작을 구현하기 위해 제작
- Mocha - LiveScript - JavaScript로 명칭 변경
- 표현식expression 👉 명령문statement 👉 응용프로그램application

# 변수

 - `변경 가능한` 값을 저장하기 위한 기억 공간(메모리) : 메모리 주소에 변수명/식별자 를 통해 값을 넣는것
 - 사용하기전 반드시 선언 필요
 - 중복 선언 불가
 - 키워드 var, let

# 상수

 - `변경 불가능한` 값을 저장하기 위한 공간
 - 사용하기 전 반드시 선언과 초기화가 필요해
 - 중복 선언 불가
 - 키워드 const

# 호이스팅

 - 코드에 선언된 변수 및 함수를 유효한 범위의 코드 상단으로 끌어 올리는 작업
 - var의 변수/함수의 선언만 위로 올려지고, 할당은 올려지지 않음
 - let/const변수 선언과 함수 표현식에서는 호이스팅 발생하지 않는데

# 자료형 종류

 - 원시타입 
    - Boolean
    - null : 존재하지 않거나 유효하지 않는 주소 표시
    - undefined : 선언 후 값을 할당하지 않은 변수
    - `Number`
        - 문자열로 변환하는 .toString(), `.toString(16/8/2/...)` 등 안에 숫자를 넣으면 `해당 진법으로 10진수의 수를 변환`
        - n진법의 숫자를 변환 `parseInt(bin,2)` 👉 bin이라는 2진수를 10진수로 변환
        - 소수점 몇자리까지 제한하여 표현하는 .toFixed(), .toPrecision(): 정수를 포함해서 몇개까지 표현할것인지
        - 타입을 확인하는 .isNaN(), .isFinite()
    - `String` : 문자나 문자열을 표현하는 자료형
        - 길이 : length
        - 검색 : indexOf(문자),lastIndexOf(-1 사용가능), includes(), startsWith(), charAt(index) ... 등등
        - 변환 : toUpperCase(), toLowerCase(), `splice는` 원본배열에서 n번째 요소에서 k개 추출하고 새로운 요소를 넣는 등 변환
        - 치환 : replace()
        - 추출 : slice(start,end), substring(start,length) ... 등등 `slice는` 원본배열에서 추출하는것. -1은 마지막 요소야. 
        - 분할 : split(정규표현식, 개수(option))
    - Symbol
 - 객체타입 : object로 두개 이상의 복잡한 개체 저장이 가능해. key는 `value의 주소값`을 참조(reference)하는것이야. 
    - `배열` : 여러 개체값을 순차적으로 나열한 자료구조. C나 자바의 배열과 같은 기능을 하는 객체이지만, 이들과는 다르게 굳이 크기를 지정하지 않아도 되며, 어떤 위치에 어떤 타입의 데이터를 저장하더라도 에러가 발생하지 않습니다. 그리고 일반적인 배열은 `연속적인 밀집 배열`이지만 자바스크립트의 배열은 해시기반의 `비 연속적인 희소 배열`이다.
        - 추가/삭제 : push, pop, shift, unshift, 등등..
        - 변형 : sort(), reverse(), join() 등등..
        - 검색 : `find(item, index, array)` : 만족하는 값을 찾으면 해당 인덱스의 값 하나를, 없으면 -1을 출력해, `filter(item, index, array)` : 만족하는 모든 값들을 배열로 출력
        - 누적합 : `reduce(acc, item, index, array)` : 초기값을 지정할 수 있어.
    - `Map` : `다양한 자료형`의 key를 허용(Object는 문자열만 key값으로 사용함)하는 key-value형태의 자료형을 저장 가능한 Collection
        - 크기 : `size`
        - 추가 : `set(key,value)`
        - 접근 : `get(key)`
        - 삭제 : delete(key)
        - 전체삭제 : clear()
        - 존재여부 확인 : `has(key)`
        - 그 외 : keys(), values(), entries(), `Obeject.fromEntries(Map 객체)` : Map객체를 Object로 변경,` Object.entries(Objcet객체)` : Object👉[key,value]형태로 변경. 이 key-value를 다시 new Map(key-value)를 하면 Map 객체로 복원 가능.
    - `Set` : 중복된 value 허용하지 않는 Collection. 대부분 Map 과 비슷
        - 추가 : `add(value)`
    - Date : get,set으로 날짜 정보를 얻고, 설정할 수 있음. new Date(Date.UTC(연, 월,일)) 하면 현재위치 기준의 시간을 알 수 있어.
        - 날짜 정보 얻기 : 연/월/일 👉 getFullYear(), getMonth(), getDate()
        - 시간 정보 얻기 : 시/분/초 👉 getHours(), getMinutes(), getSeconds()

# 객체 복사의 문제점

단순 '=' 을 통한 객체복사는 `value의 주소값`을 참조하는것이야. 즉, 변수명/식별자의 이름은 다른데 참조하는 메모리의 주소는 같은것이다 라는 것이지.
실제 value값을 복사하기 위해서는 `얕은 복사(Shallow copy)` 혹은 `깊은 복사(Deep copy)`를 통해 가능하지.
 1. for문을 통한 복사
 2. Object.assign({}, 복사할 객체)
 3. {...복사할 객체} : spead 문법
 하지만 얕은 객체의 문제점은 아직도 존재. `객체 내에 또 다른 객체`가 있다면 복사되지 않고 참조가 되어버려 👉 깊은복사

 1. 여러 중첩 for문을 통해 내부 객체까지 다 복사하는 방법
 2. `JSON객체를 통해` 깊은복사. stringfy는 객체를 문자열로 변환하는데 이떄 원본 객체와의 참조가 끊김 👉 객체를 문자열로 인식해버리는거야.
    - `JSON.stringfy` : object 👉 string, `JSON.parse` : string 👉 object

# JS 에서 false 취급하는것들

"" : 빈 문자열, NaN, null, undefined, 숫자 0
그 외 문자열, 문자 '0'이나 0 이외의 모든 수는 true

# Scope

 - 변수 혹은 상수에 접근할 수 있는 범위
 - 모듈/함수 내 코드에서 동일한 변수 사용시 간섭을 줄이는 용도로 사용
 - Scope는 Global과 Local타입으로 구분

# Label이란?

프로그램 내 특정 영역을 지정하여 별도 이름을 붙이는 식별자
break와 continue를 사용하는 반복문 안에서만 사용 가능하며, break나 continue 지시자 위에 있어야 함. 
```
end : for(let i=0; i<10; i++){
    for(let j=0; j<10; j++){
        console.log(`$(i) + $(j) = $(i + j)`);
        break end;
    }
}
```
로 하면 break 문을 만난 동시 end 라벨링이 된곳으로 돌아가서 종료를 함.(이런게 있다 라고만 알아가는 정도)

# 함수 정의

1. 함수 선언식 : function으로 선언
2. 함수 표현식 : var/let/const 변수안에 함수를 선언 (이름없는 함수를 사용)
3. 화살표 함수 : ES6 에서 등장한 화살표함수

# 콜백함수

콜백함수는 다른 `함수의 매개변수`로 전달되어 수행되어지는 함수
고차함수는 `매개변수를 통해 함수`를 받아 호출하는 함수
👉 고차함수의 매개변수로 들어오는 함수가 콜백함수다.
```
function calculator(callback, x,y){
    return callback(x,y)
}
calculator:고차함수, callback:콜백함수
```

# call by *

함수를 호출할 때 얕은호출이 발생되게 되는건가?
`call by value`
    - 값에 의한 복사로 함수 내에서 매개 변수 값을 변경 시켜도 영향을 미치지 않음
    - 원시타입을 매개 변수로 넘겼을 때 발생

`call by reference`
    - 주소에 대한 복사로 함수 내에서 매개 변수 내 값을 변경시키면 `원본 데이터`에도 영향을 받음
    - 객체타입을 매개 변수로 넘겼을 때 발생

# this

메서드에서 객체 내부의 속성(property) 값을 접근할 수 있는 지시자
this는 runtime에 의해 결정되어 호출한 객체에 따라 다르다.
 - 일반함수 : 자기 자신을 가리킴. 호출한 객체겠지?
 - 객체 : 호출한 객체
 - 화살표함수 : 상위의 화살표함수가 아닌 함수를 가르킴. 없으면 전역객체인 window를 가르킴

 # 생성자 함수

  - 유사한 객체를 다중으로 만들 떄 사용되는 함수 (타 언어에서는 class로 쓰임)
  - 일반적으로 생성자 함수의 첫 글자는 대문자로 시작
  - 생성자 함수로 객체 생성 시 new 연산자를 통해 객체 생성 new Object, new Array ... 등등

# N차원 배열 생성
초기 배열을 위한 메모리를 할당하고, 그 메모리 안에 다음 차원의 배열의 메모리를 참조. 👉 메모리 주소값이 차례대로 들어오겠지
 - 2/3... 차원 지도 정보, RGB를 저장하는 2차원 사진 파일 등을 표현할 떄 활용 가능한데, 코딩테스트에도 자주 나오는 유형이지.
 - 빈 배열을 만들어서 새로운 Array를 push하면서 다차원 배열을 생성 가능해.
 - 접근 : index 👉 index ... 해서 접근. 참조된 주소를 통해 그 메모리 주소 안에 값을 접근한다

# 프로토타입 (prototype)
- 어떠한 객체가 만들어지기 위해 객체의 모태가 되는 원형 객체
- 자바스크립트는 일반적인 객체지향 언어와는 다르게, 프로토타입을 이용한 복사(Cloning)을 통해 새로운 객체 생성
- 일반적인 객체 생성 방식: `속성은 생성자, 메서드는 프로토타입에서 정의`