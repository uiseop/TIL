# 왜 코딩 테스트를 보는가?

SW 기본 역량을 정량적으로 평가하는데 이 코딩테스트가 매우 유효하다고 생각한다. SW 기본 역량은 `문제해결 능력` + `구현 능력`이 갖춰져야 문제를 풀 수 있기때문에 이게 바로 SW 기본 역량이다. 따라서 이 역량을 평가하는데 제일 좋은 정량적 지표가 되기 때문에 코딩 테스트를 보는것이 아닐까 싶습니다. 
 - `문제 해결 능력` : 요구 사항이 들어왔을 때 이 요구 사항을 어떤 구현을 통해서 문제를 해결할 것인가? 아이디어
 - `구현 능력` : 언어에 맞춰 실제 이 요구 사항을 어떻게 Sw적으로 해결해 나갈것인가

# JS란??

- 객체 기반의 스크립트 프로그래밍 언어`(라인별로 실행되는)` 인터프리터 언어 (C,Java랑 달리 별도의 컴파일이 없어)
- ECMAScript 사양을 준수하는 범용 스크립팅 언어
- 자바와 연관은 없음. 웹의 동적 동작을 구현하기 위해 제작
- Mocha - LiveScript - JavaScript로 명칭 변경
- 표현식expression 👉 명령문statement 👉 응용프로그램application

# 변수

 - `변경 가능한` 값을 저장하기 위한 기억 공간(메모리) : 메모리 주소에 변수명/식별자 를 통해 값을 넣는것
 - 사용하기전 반드시 선언 필요
 - 중복 선언 불가
 - 키워드 var, let

# 상수

 - `변경 불가능한` 값을 저장하기 위한 공간
 - 사용하기 전 반드시 선언과 초기화가 필요해
 - 중복 선언 불가
 - 키워드 const

# 호이스팅

 - 코드에 선언된 변수 및 함수를 유효한 범위의 코드 상단으로 끌어 올리는 작업
 - var의 변수/함수의 선언만 위로 올려지고, 할당은 올려지지 않음
 - let/const변수 선언과 함수 표현식에서는 호이스팅 발생하지 않는데

# 자료형 종류

 - 원시타입 
    - Boolean
    - null : 존재하지 않거나 유효하지 않는 주소 표시
    - undefined : 선언 후 값을 할당하지 않은 변수
    - Number
    - String : 문자나 문자열을 표현하는 자료형
    - Symbol
 - 객체타입 : object로 두개 이상의 복잡한 개체 저장이 가능해. key는 `value의 주소값`을 참조(reference)하는것이야.

# 객체 복사의 문제점

단순 '=' 을 통한 객체복사는 `value의 주소값`을 참조하는것이야. 즉, 변수명/식별자의 이름은 다른데 참조하는 메모리의 주소는 같은것이다 라는 것이지.
실제 value값을 복사하기 위해서는 `얕은 복사(Shallow copy)` 혹은 `깊은 복사(Deep copy)`를 통해 가능하지.
 1. for문을 통한 복사
 2. Object.assign({}, 복사할 객체)
 3. {...복사할 객체} : spead 문법
 하지만 얕은 객체의 문제점은 아직도 존재. `객체 내에 또 다른 객체`가 있다면 복사되지 않고 참조가 되어버려 👉 깊은복사

 1. 여러 중첩 for문을 통해 내부 객체까지 다 복사하는 방법
 2. `JSON객체를 통해` 깊은복사. stringfy는 객체를 문자열로 변환하는데 이떄 원본 객체와의 참조가 끊김 👉 객체를 문자열로 인식해버리는거야.
    - `JSON.stringfy` : object 👉 string, `JSON.parse` : string 👉 object

# JS 에서 false 취급하는것들

"" : 빈 문자열, NaN, null, undefined, 숫자 0
그 외 문자열, 문자 '0'이나 0 이외의 모든 수는 true

# Scope

 - 변수 혹은 상수에 접근할 수 있는 범위
 - 모듈/함수 내 코드에서 동일한 변수 사용시 간섭을 줄이는 용도로 사용
 - Scope는 Global과 Local타입으로 구분

# Label이란?

프로그램 내 특정 영역을 지정하여 별도 이름을 붙이는 식별자
break와 continue를 사용하는 반복문 안에서만 사용 가능하며, break나 continue 지시자 위에 있어야 함. 
```
end : for(let i=0; i<10; i++){
    for(let j=0; j<10; j++){
        console.log(`$(i) + $(j) = $(i + j)`);
        break end;
    }
}
```
로 하면 break 문을 만난 동시 end 라벨링이 된곳으로 돌아가서 종료를 함.(이런게 있다 라고만 알아가는 정도)