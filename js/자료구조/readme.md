# 배열

- new Array()로 자바스크립트는 c나 java와는 다르게 밀집 배열이 아니라, 희소 배열로 만들어져있어(Hash기반 👉 key값으로 인덱스를 접근)

# 프로토타입

- 어떤 객체가 만들어지기 위해 객체의 모태가 되는 `원형`
- JS는 일반적인 객체지향 언어오는 다르게, 프로토타입을 이용한 복사(Cloning)을 통해 새로운 객체 생성
- 일반적인 객체 생성 방식 : 속성은 생성자, 메서드는 프로토타입에서 정의
- `prototype를` 이용하여 객체에 `메서드를 추가하고`, `새로 생성된 객체들`은 해당 메서드를 `사용할 수 있어`

# 연결 리스트(Linked List)

- 각 노드가 데이터와 포인터를 갖는데, `한 줄`로 연결되어 있는 방식으로 데이터를 저장하는 자료 구조 `Head 👉 다음 Node`
- 노드 추가 : LinkedList.`append()/insert()`
- 노드 삭제 : LinkedList.`remove()/removeAt()`
- 데이터 위치 : LinkedList.`indexOf()`

- 🔥 이점 ? 인덱스만 알면, 데이터를 `추가/삭제`할 시 매우 빠른 퍼포먼스를 보여줌

# 이중 연결 리스트(Double Linked List)

- 연결리스트랑 동일한데, 각각 `연결이 두줄로` 연결되어있어
- 노드 개수/ 비어있는지?
- 출력/역출력
- 노드 추가
- 노드 삭제
- 데이터 위치 확인

- 🔥 DLL은 tail이라는 포인터가 있어서 O(1)만큼이 빠르다! `LL < DLL 좋다!`

# 원형 연결 리스트

- LL와 완전 같음. `차이점`은 마지막 노드가 가리키는곳은 `Head가 가리키는 노드 돼`

# 스택

- `LIFO`구조로 한쪽이 뚫려있는 통나무를 생각하면 좋아!
- DFS문제에서 많이 사용 돼! 가장 최근것을 뽑아내서 차곡차곡 진행
- 배열을 사용해서 많이 구현하지

# 큐

- `FIFO`구조로 양쪽이 열려있는 빈 통이야
- shift/unshift를 사용해서 사용하면 O(n)만큼의 시간복잡도가 걸려. 어쨋든 사용되는 자료구조는 Array이기 떄문에 모든 아이템을 한칸씩 뒤로/앞으로 만들어줘야하기때문에 O(n). 하지만 해당 index를 `delete시켜` undefined로 만들고, `head의 위치르 한칸씩` 이동시킨다 👉 `O(1)만큼만 걸린다`
- `shift, unshift보단 index`로 처리하는것을 권장한다.

# 우선순위 큐

- `우선순위를 고려하여` 먼저 넣은 데이터가 먼저 나오는 자료구조로, FIFO인건 동일 해
- 우선순위 정렬 방식 : 배열 기반, 연결리스트 기반, Heap 기반 등의 정렬 방식 존재 해
- 앞선 스택과 큐는 데이터(key)만 저장했다면 우선순위 큐는 우선순위(Value)까지 저장하도록 해!
- 이럴경우는 배열보단 Map(Hash)기반으로 만드는게 더 편할듯싶음!

# 원형 큐

- 원형 형태를 가져서 원형 연결. FIFO인건 동일 해
- head랑 tail이 계속 움직이면서 `unshift()` 보다 좋은 성능을 보여줘

# 딕셔너리 - JS에서는 Map 자료구조임

- key,value로 이뤄진 자료구조

# 해시함수

- 임의의 길이의 데이터를 `고정된 길이의 데이터로 매핑`하는 함수 👉 Map이랑 비슷한데 모든 키값의 길이가 고정된것만 다르네
- 압축성 : 다양한 가변 길이의 입력에 대해 고정된 크기의 결과값을 반환하는 성질
- 효율성 : 어떤 입력 값에 대해서도 많은 자원과 시간이 소요되지 않고 처리됨
- 저항성 : 결과값을 바탕으로 입력 값을 찾는 것이 불가능함

- 해싱처리를 함에 따라 해시 값이 동일하게 될 경우가 발생 👉 `해시 충돌`
 1. 해시 함수 변경
 2. 자료구조 확장 : 선형 조사법, 이중해시, 체이닝 등의 방법을 통해 `다양한 해시값`을 도출