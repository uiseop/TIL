# 알고리즘 문제를 매일 풀면서 JS 메서드들을 익혀보자.

## 목차 <hr/>
- <a href="#1">백준에서 자바스크립트 사용하는 법</a>
- <a href="#2">Graph</a>
    - <a href="#2_1">Dijkstra</a>: 한 정점에서 나머지 모든 정점으로의 최단 거리 구하는 알고리즘
    - <a href="#2_2">Kruskal</a>: 주어진 그래프에서 최소 간선들로 이뤄진 트리를 반환하는 알고리즘. 시간 복잡도는 O(ElogE)
    - <a href="#2_3">Prim</a>: Kruskal과 같다. 하지만 시간 복잡도는 O(ElogV) (`E개의 간선 * 간선을 통해 삽입된 정점 V의 가중치 정렬`) + O(VlogV) (`V개 정점을 Exract 하는 시간`). 때문에 그래프 내의 `간선이 많은` 경우는 `Prim`, `적은` 경우 `Kruskal`이 유리
<hr/>


## <p id="1">백준에서 자바스크립트로 문제 풀기</p>
백준에는 자바스크립트가 없다. 그래서 node.js를 통해 문제를 풀어야 한다고 한다.  

때문에 CommonJS 라이브러리를 사용해서 문제를 풀어야 하고, 라이브러리를 import 하기 위해서는 `require("..")`를 사용한다.  

```js
let fs = require("fs")
let input = fs.readFileSync("/dev/stdin").toString().split(" ")
➡️ 위의 코드는 백준 사이트에서 예제들의 채점을 위한 stdin 경로를 표시
let input = fs.readFileSync("test.txt").toString().split("\n")
➡️ 로컬에서 돌릴때는 "test.text"로 하도록 한다.
let a = parseInt(input[0])
let b = parseInt(input[1])
```
코드를 보면 Node.js의 `built-in file system module`을 사용  
dev 디렉터리의 stdin 파일을 읽어서 string의 split 메서드를 사용하기 위해 모든 input 들을 toString 시켜주고 split을 진행해주는것으로 보인다.  
그런 후 string 처리 된 Number들을 다시 parseInt/Number로 정수로 만들어준다.  

### 그럼 parseInt와 Number의 차이점은 뭐지..?
- parseInt: 문자열의 인자를 숫자로 변경해준다. 대신 `숫자로 시작`하는 경우 숫자로 변경해주고 그렇지 않으면 `NaN`을 return하게 된다.  또한 `1000원`같이 숫자로 시작하면서 string이 함께 있을 때 숫자가 끝날때 까지만 형변환을 진행해준다.  
- Number: 문자열이 숫자이면 숫자로 변형하고, 문자열이 하나라도 껴 있으면 NaN을 return하게 된다. 

✅ 결론: parseInt가 Number보다 좀 더 유연하게 형변환을 진행하기때문에 앞으로 parseInt를 자주 사용해보도록 한다.
## <p id="2">Graph</p>

### 비선형 자료구조 -> Object(객체)를 사용한다
Object의 메서드를 알아봐야지? 
- Object.keys(obj): obj객체의 모든 key값들을 배열로 반환한다
- Object.values(obj): obj객체의 모든 value값들을 배열로 반환한다
- Object.entries(obj): obj객체의 `[key,value]`로 이뤄진 이차원 배열을 반한다.

### new 연산자 -> 생성자 함수를 생성할 때 반드시 필수
```js
function User(name) {
  // this = {};  (빈 객체가 암시적으로 만들어짐)

  // 새로운 프로퍼티를 this에 추가함
  this.name = name;
  this.isAdmin = false;

  // return this;  (this가 암시적으로 반환됨)
}
```
`new` 연산자를 사용해서 User 객체를 생성하면 새로운 객체가 생성된다.

### <p id="2_1">Dijkstra 알고리즘</p>

`Single Source Shortest Path` 이란 하나의 출발점에서 각 정점까지 도달하는데 비용을 계산하여 최단 경로를 구하는 것 입니다. 

하나의 정점에서 다른 정점으로 가는데 payload를 계산하여 가장 최단 거리를 구하는건 계산에 있어 많은 이점을 주기때문에 실생활에서 가장 필요한 알고리즘이 아닐까 생각이 듭니다. 

`Single Source Shortest Path`와 대비되는 주제로는 `All Pair Shortest Path`가 있는데 ASP는 모든 정점끼리의 최단 경로를 계산합니다. 즉, SSP는 1차원 배열로써 각 정점까지 경로의 비용을 표현할 수 있지만, ASP는 2차원 배열이 필요하다고 합니다. 이는 다음에 살펴보도록 하고, 우선 하나의 정점에서 출발하여 모든 정점으로의 최단 경로를 계산하는데 있어 경로에 `음의 가중치`가 있느냐 없느냐에 따라 알고리즘이 달라진다고 합니다.  

- 음의 가중치를 허용: **Bellman-Ford**알고리즘
- 음의 가중치 허용X: **Dijkstra**알고리즘

Dijkstra 알고리즘은 한 정점에서 다른 정점들로의 최소 비용을 계산하는 알고리즘이기 떄문에 우리가 아는 최대/최소값을 빠른 속도로(`O(logN)`) 계산하는 힙(Heap) 자료구조가 필요할것으로 예상됩니다. 힙 자체가 우선순위 큐를 위해서 만들어진 자료구조이고, 우선순위를 가중치가 가장 낮을수록 높게 주면 된다.  

때문에 우리는 2개의 자료구조가 필요하게 된다. 우선 정점간의 거리를 저장하는 `Distance 객체` 그리고 우선순위 큐가 필요하다. 일단 오늘은 객체를 사용해서 값을 저장하고, 한 정점에 연결된 모든 간선들을 확인하여 최솟값을 찾으면 된다.

글로만 작성하려니 힘들긴하지만.. 나머지는 코드를 보면서 확인하자.

이 떄 최소 우선순위 큐에는 `[vertex, weight]`정보가 들어가야하고, 우선순위는 weight를 기준으로 한다. distance객체에서는 그 노드로 가는데 드는 비용을 저장하고, 한번 우선순위 큐에서 pop해서 가지치기를 한 노드는 중복 계산을 피하기 위해 Visited 객체를 생성해서 중복을 방지해준다.

### <p id="2_2">Kruskal 알고리즘</p>

주어진 그래프에서 안전 간선을 연결하여 최소한의 비용으로 이루어진 트리를 만드는 것이 목적입니다.  

Kruskal's 알고리즘은 안전 간선을 연결할 때 Union - Find 자료구조를 이용합니다.  

위의 자료구조를 이해하는 것이 Kruskal's 알고리즘의 핵심이므로 이 내용을 먼저 살펴보겠습니다.  

#### Union - Find

Union - Find 자료구조는 이름 그대로 " 찾고 합치는 과정 " 입니다.

예를 들어, 3개의 트리가 있다고 하겠습니다.

이 트리들은 정점 1, 2, 3, 4, 5, 6, 7, 8이 각각 집합을 이루고 있다가 Union이 진행된 중간 단계입니다.

즉, { 1, 2 }  |  { 3, 4, 5 }  |  { 6, 7, 8 } 이렇게 3개의 집합으로 나뉜 것을 표현했습니다.

각 트리를 집합이라고 표현할 때 대표 값은 그 집합을 대표하는 값입니다.

트리 A의 모든 노드들은 대표 값으로 1을 갖고 있으며, 트리 B의 모든 노드들은 3, 트리 C는 6을 대표 값을 갖습니다.

대표 값이 필요한 이유는 두 정점을 합칠(Union) 때 서로 같은 집합이 아닌지 확인(Find)하기 위함입니다.

예를 들어, 위의 그림에서 1과 2를 합친다고 할 때 두 정점은 대표 값이 1이기 때문에 서로 같은 집합입니다.

그래서 1과 2는 합치는 작업을 하지 않습니다.

사실 1과 2는 이미 Union이 진행된 상태였기 때문에 같은 부모를 갖게 되죠.

바로 뒤에서 살펴보겠지만 서로 다른 대표 값을 갖는 두 집합을 Union하면 대표값을 통일함으로써 Union을 수행합니다.

이 때 두 정점의 대표 값을 확인한 작업이 Find 연산입니다.

### <p id="2_3">Prim 알고리즘</p>

Prim's 알고리즘의 경우는 맨 처음에 확인한 `Dijkstra 알고리즘`과 **유사**합니다. 어떤 면에서 유사한가? 바로 **최소 우선순위 큐**를 사용하는 면에서 유사한 알고리즘이라고 할 수 있겠습니다. **최소 우선순위 큐** 자료구조를 사용해서 최소한의 비용을 갖는 트리를 만드는 알고리즘인데 과연 이 알고리즘이 Kruskal 알고리즘과 어떤 면에서 차이가 있는지 확인해보겠습니다. 

##### Step 1. 
우선 `Dijkstra 알고리즘`과 같이 모든 정점의 값을 `inf`로 설정합니다. 모든 정점들 중 가장 최솟값을 뽑아 그 정점을 이용하여 다음 단계를 진행하게 되기 때문입니다.

#### Step 2.
최솟값을 갖는 Vertex를 큐에서 pop 시킨 후, Edge들을 연결하면서 기존에 연결된 가중치와 비교하고, 작다면 Update 해 줍니다.  
여기서 `Dijkstra 알고리즘과 다른점`은 Dijkstra 알고리즘과 달리 Prim 알고리즘은 이전 연결된 가중치들의 누적합이 아닌 지금 현재 Vertex와 연결된 다른 Vertex의 가중치의 최소값을 설정합니다.  

이 덕분에 Prim 알고리즘으로 만들어진 트리는 `시작 정점`을 어디로 설정하든 같은 트리 결과가 나오게 됩니다.

#### 그럼 모든 Vertex에서 최소 가중치를 갖는 Edge만 선택하면 되겠네??
아닙니다. 결국 Prim 알고리즘에서 요구하는 return은 `트리`구조이기 때문에 자칫 최소 가중치의 Edge들만 선택하면 Cycle이 생기거나(`간선의 개수가 n개`), 모든 정점들이 연결되지 않는 결과(`간선의 개수가 n-1개보다 적음`)가 나타날 수 있습니다. 때문에 최소한의 비용을 갖는 트리는 BFS탐색처럼 차근차근 진행해야 합니다. 때문에 시작이 어떤 간선이든간에 `항상 같은 트리를 return`하게됩니다

### <p id="2_4">위상 정렬</p>

**위상 정렬**은 `"순서가 정해져있는 작업"`을 차례대로 수행해야 할 때 그 순서를 결정해주기 위해 사용하는 알고리즘입니다. 순서가 정해져있다 함은 어떤 일을 할 때 사전에 해결되어야 할 작업이 있다는 것이고, 그러한 작업들이 모두 완료가 된 후에 다음 작업을 진행하는 것 입니다.  

그렇기 때문에 위상정렬은 모든 일의 `시작과 끝`이 명확히 구분되어있기때문에 **DAG(Directed Acyclic Graph)**에만 적용이 가능합니다. DAG는 사이클이 발생하지 않는 방향 그래프를 의미합니다. 

그렇다면 차례대로임을 어떻게 프로그래밍적으로 구현하느냐?? 

#### Step 1.
시작 노드를 찾는다.  

시작 노드라 함은 자신에게 연결된 간선이 0개인 노드를 의미합니다. 사이클이 없는 그래프이기때문에 그러한 노드는 반드시 존재할것이고, 이 노드가 바로 시작 노드가 되는 것 입니다.

#### Step 2.
노드와 연결된 다른 노드들을 확인한다. 이 때 시작노드를 제외하고 차수가 0이 되는 노드라면 `Queue`에 추가하고, 그렇지 않은 노드는 사전에 작업이 필요한 노드가 있다는 것 이기 떄문에 `Queue`에 넣지 않습니다. 

이렇게 해서 차례대로 구현할 수 있습니다. 그래프 이론들 중 가장 쉬운것 같군용. 홍홍홍🤗🤗🤗

### <p id="3_1">실제 객체 생성 시 문제점</p>

시간 복잡도는 점근적인 효율성을 보여줄 뿐이다. 단순히 통과/시간 초과로 나누지 말고, 통과된 코드가 얼마나 시간이 걸렸는지 확인하는것이 좋다.
트리를 직접 구현한 class나 prototype을 사용하는 `객체`는 그 자체로 상당히 무거운 녀석이라고 한다. 객체를 만다는것 자체가 시간 복잡도 측면에서 많은 컴퓨팅 연산을 요구한다고 보면 된다. 이것들을 전부 노드 하나당 하나의 객체를 할당하고, (`Tree의 구성요소 Node를 전부 객체로 할당`) 서로 엮어서 실제로 트리를 구현하는 것은 대충 보기에도 매우 무거운 연산이다.